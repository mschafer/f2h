#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/Triple.h"
#include "llvm/DebugInfo/DIContext.h"
#include "llvm/DebugInfo/DWARF/DWARFContext.h"
#include "llvm/DebugInfo/DWARF/DWARFFormValue.h"
#include "llvm/Object/ObjectFile.h"
#include "llvm/Object/RelocVisitor.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/Format.h"
#include "llvm/Support/ManagedStatic.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/PrettyStackTrace.h"
#include "llvm/Support/Signals.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/Dwarf.h"
#include <algorithm>
#include <cstring>
#include <list>
#include <string>
#include <system_error>
#include <iostream>
#include <fstream>
#include "Variable.hpp"
#include "CommonBlock.hpp"
#include "Subprogram.hpp"

using namespace llvm;
using namespace object;

static cl::list<std::string>
InputFilenames(cl::Positional, cl::desc("<input object files>"),
               cl::ZeroOrMore);

static cl::opt<std::string> OutputFilename("output", cl::value_desc("output"),
                                           cl::init("-"), cl::desc("Output file"));
static cl::alias OutputFilenameA("o", cl::desc("Alias for --output"),
                          cl::aliasopt(OutputFilename));

static std::ostream *outputStream(&std::cout);

static int ReturnValue = EXIT_SUCCESS;

static bool error(StringRef Filename, std::error_code EC) {
  if (!EC)
    return false;
  errs() << Filename << ": " << EC.message() << "\n";
  ReturnValue = EXIT_FAILURE;
  return true;
}

/**
 * Traverse the graph looking for common blocks and subprograms.
 * Assume the starting node is an object file with a single compile unit.
 * Immediate children of the compile uniit will be subprograms.
 * Immediate children of the subprograms will be the common blocks.

 http://llvm.org/doxygen/classllvm_1_1DWARFDebugInfoEntryMinimal.html
 http://www.dwarfstd.org/doc/DWARF4.pdf
 */
static void extractObject(ObjectFile &obj)
{
    std::unique_ptr<DWARFContextInMemory> DICtx(new DWARFContextInMemory(obj));


    auto cuit = DICtx->compile_units();
    for (auto &cu : cuit) {
        
        // calling this with false reads in the entire DIE list for this cu so we can walk through it.
        auto cudie = cu->getUnitDIE(false);
        
        // ensure compilation unit is fortran
        DWARFFormValue form;
        cudie->getAttributeValue(cu.get(), dwarf::DW_AT_language, form);
        auto lang = form.getAsUnsignedConstant().getValueOr(-1);
        if (!(lang == dwarf::DW_LANG_Fortran77 ||
              lang == dwarf::DW_LANG_Fortran90 ||
              lang == dwarf::DW_LANG_Fortran95)) {
            errs() << cudie->getName(cu.get(), DINameKind::ShortName) << " is not FORTRAN 77,90, or 95.  Skipping\n";
            continue;
        }
        
        *outputStream << "// compilation unit: " << cudie->getName(cu.get(), DINameKind::ShortName) << std::endl;
        
        // look for children of the compile unit that are subprograms
        // immediate children of the subprogram include parameters, common blocks, and local variables
        auto die = cudie->getFirstChild();
        while (die && !die->isNULL()) {
            if (die->isSubprogramDIE()) {
                try {
                    Subprogram::Handle sub = Subprogram::extract(die, cu.get());
                    // empty return w/o error means not a callable subprogram so just ignore
                    if (sub) {
                        *outputStream << sub->cDeclaration() << std::endl;
                    }
                } catch (std::runtime_error &ex) {
                    // skip the subroutine if something goes wrong with the extraction
                    // err message printed at site of throw
                }
            }
            die = die->getSibling();
        }
        *outputStream << std::endl;
    }

}

int main(int argc, char **argv) {
    // Print a stack trace if we signal out.
    sys::PrintStackTraceOnErrorSignal();
    PrettyStackTraceProgram X(argc, argv);
    llvm_shutdown_obj Y;  // Call llvm_shutdown() on exit.
    
    cl::ParseCommandLineOptions(argc, argv, "f2h\n");
    
    // Defaults to a.out if no filenames specified.
    if (InputFilenames.size() == 0) {
        errs() << "no input files specified" << '\n';
        return EXIT_FAILURE;
    }
    
    if (OutputFilename.compare("-")) {
        outputStream = new std::ofstream(OutputFilename.c_str(), std::ofstream::trunc);
    }
    
    
    // output header
    // kludge c99 complex compatibility with c++
    *outputStream << "// automatically generated by f2h" << std::endl << std::endl <<
    "#include <stdint.h>" << std::endl << std::endl <<
    "#ifdef __cplusplus" << std::endl <<
    "#include <complex>" << std::endl <<
    "using float_complex = std::complex<float>;" << std::endl <<
    "using double_complex = std::complex<double>;" << std::endl <<
    "using long_double_complex = std::complex<long double>;" << std::endl <<
    "extern \"C\" {" << std::endl <<
    "#else" << std::endl <<
    "#include <complex.h>" << std::endl <<
    "typedef float complex float_complex;" << std::endl <<
    "typedef double complex double_complex;" << std::endl <<
    "typedef long double complex long_double_complex;" << std::endl <<
    "#endif" << std::endl << std::endl;

    for (StringRef filename : InputFilenames) {
        ErrorOr<std::unique_ptr<MemoryBuffer>> BuffOrErr = MemoryBuffer::getFileOrSTDIN(filename);
        if (error(filename, BuffOrErr.getError())) {
            errs() << "failed to open " << filename << '\n';
            continue;
        }
        std::unique_ptr<MemoryBuffer> Buff = std::move(BuffOrErr.get());
        
        ErrorOr<std::unique_ptr<ObjectFile>> ObjOrErr =
        ObjectFile::createObjectFile(Buff->getMemBufferRef());
        if (error(filename, ObjOrErr.getError())) {
            errs() << "failed to create object file " << filename << '\n';
            continue;
        }
        ObjectFile &Obj = *ObjOrErr.get();
        extractObject(Obj);
    }
    
    // output common blocks
    *outputStream << std::endl << std::endl << "// common blocks" << std::endl;
    for (auto &cbit : CommonBlock::map_) {
        *outputStream << cbit.second->cDeclaration() << std::endl;
    }

    *outputStream << "#ifdef __cplusplus" << std::endl << "}" << std::endl << "#endif" << std::endl;
    
    if (outputStream != &std::cout) {
        delete outputStream;
    }

    return ReturnValue;
}
